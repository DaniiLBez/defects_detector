@startuml

abstract class BaseDataLoader {
 + load_data(path: str) -> Dict[str, Any]
 + get_point_cloud(self, data: Dict[str, Any], **kwargs) -> Dict[str, Any]
 + normalize(self, points: np.ndarray) -> np.ndarray
 + get_dataset_files(self, input_dir: str, split: str) -> List[Dict[str, Any]]
 + get_save_path(self, file_info: Dict[str, Any], base_save_path: str) -> str
}

abstract class BasePatchCutter {
 + cut_patches(self, data: Dict[str, Any], **kwargs) -> List[Dict[str, Any]]}
 + sample_and_group(self, points: Tensor, npoint: int, nsample: int, indices: np.ndarray) -> Tuple[Tensor, np.ndarray]
 + sample_query_points(self, target_points: np.ndarray, query_num: int) -> Tuple[np.ndarray, np.ndarray]
}

class MVTec3DLoader {
 + load_data(path: str) -> Dict[str, Any]
 + get_point_cloud(self, data: Dict[str, Any], **kwargs) -> Dict[str, Any]
 + normalize(self, points: np.ndarray) -> np.ndarray
 + get_dataset_files(self, input_dir: str, split: str) -> List[Dict[str, Any]]
 + get_save_path(self, file_info: Dict[str, Any], base_save_path: str) -> str

}

class MVTec3DPatchCutter {
 + group_size: int
 + group_mul: int
 + cut_patches(self, data: Dict[str, Any], **kwargs) -> List[Dict[str, Any]]}
 + sample_and_group(self, points: Tensor, npoint: int, nsample: int, indices: np.ndarray) -> Tuple[Tensor, np.ndarray]
 + sample_query_points(self, target_points: np.ndarray, query_num: int) -> Tuple[np.ndarray, np.ndarray]

}

class PatchCutterService {
 + data_loader: BaseDataLoader
 + patch_cutter: BasePatchCutter
 + save_path: str

 + process_file(self, input_file: str) -> Dict[str, Any]
 + process_directory(self, input_dir: str, split: str) -> List[str]
 + save_patches(self, patches: Dict[str, np.ndarray], save_path: str, split: str) -> None
}

BaseDataLoader <|.. MVTec3DLoader
BasePatchCutter <|.. MVTec3DPatchCutter

PatchCutterService o-- BaseDataLoader
PatchCutterService o-- BasePatchCutter

@enduml